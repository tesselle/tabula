% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllGenerics.R, R/deprecate.R
\docType{methods}
\name{deprecate}
\alias{deprecate}
\alias{index_heterogeneity}
\alias{index_heterogeneity-method}
\alias{index_heterogeneity,ANY-method}
\alias{index_evenness}
\alias{index_evenness-method}
\alias{index_evenness,ANY-method}
\alias{index_richness}
\alias{index_richness-method}
\alias{index_richness,ANY-method}
\alias{index_composition}
\alias{index_composition-method}
\alias{index_composition,ANY-method}
\alias{simulate_heterogeneity}
\alias{simulate_heterogeneity-method}
\alias{bootstrap_heterogeneity}
\alias{bootstrap_heterogeneity-method}
\alias{jackknife_heterogeneity}
\alias{jackknife_heterogeneity-method}
\alias{simulate_evenness}
\alias{simulate_evenness-method}
\alias{bootstrap_evenness}
\alias{bootstrap_evenness-method}
\alias{jackknife_evenness}
\alias{jackknife_evenness-method}
\alias{simulate_richness}
\alias{simulate_richness-method}
\alias{bootstrap_richness}
\alias{bootstrap_richness-method}
\alias{jackknife_richness}
\alias{jackknife_richness-method}
\alias{bootstrap_heterogeneity,CountMatrix-method}
\alias{jackknife_heterogeneity,CountMatrix-method}
\alias{simulate_heterogeneity,CountMatrix-method}
\alias{bootstrap_evenness,CountMatrix-method}
\alias{jackknife_evenness,CountMatrix-method}
\alias{simulate_evenness,CountMatrix-method}
\alias{bootstrap_richness,CountMatrix-method}
\alias{jackknife_richness,CountMatrix-method}
\alias{simulate_richness,CountMatrix-method}
\title{Deprecated Methods}
\usage{
index_heterogeneity(object, ...)

\S4method{index_heterogeneity}{ANY}(
  object,
  method = c("berger", "brillouin", "mcintosh", "shannon", "simpson")
)

index_evenness(object, ...)

\S4method{index_evenness}{ANY}(
  object,
  method = c("shannon", "brillouin", "mcintosh", "simpson")
)

index_richness(object, ...)

\S4method{index_richness}{ANY}(object, method = c("count", "margalef", "menhinick"))

index_composition(object, ...)

\S4method{index_composition}{ANY}(
  object,
  method = c("chao1", "ace", "chao2", "ice"),
  unbiased = FALSE,
  improved = FALSE,
  k = 10
)

simulate_heterogeneity(object, ...)

bootstrap_heterogeneity(object, ...)

jackknife_heterogeneity(object, ...)

simulate_evenness(object, ...)

bootstrap_evenness(object, ...)

jackknife_evenness(object, ...)

simulate_richness(object, ...)

bootstrap_richness(object, ...)

jackknife_richness(object, ...)

\S4method{bootstrap_heterogeneity}{CountMatrix}(
  object,
  method = c("berger", "brillouin", "mcintosh", "shannon", "simpson"),
  probs = c(0.05, 0.95),
  n = 1000,
  ...
)

\S4method{jackknife_heterogeneity}{CountMatrix}(
  object,
  method = c("berger", "brillouin", "mcintosh", "shannon", "simpson"),
  ...
)

\S4method{simulate_heterogeneity}{CountMatrix}(
  object,
  method = c("berger", "brillouin", "mcintosh", "shannon", "simpson"),
  quantiles = TRUE,
  level = 0.8,
  step = 1,
  n = 1000,
  progress = getOption("tabula.progress"),
  ...
)

\S4method{bootstrap_evenness}{CountMatrix}(
  object,
  method = c("berger", "brillouin", "mcintosh", "shannon", "simpson"),
  probs = c(0.05, 0.95),
  n = 1000,
  ...
)

\S4method{jackknife_evenness}{CountMatrix}(
  object,
  method = c("berger", "brillouin", "mcintosh", "shannon", "simpson"),
  ...
)

\S4method{simulate_evenness}{CountMatrix}(
  object,
  method = c("shannon", "brillouin", "mcintosh", "simpson"),
  quantiles = TRUE,
  level = 0.8,
  step = 1,
  n = 1000,
  progress = getOption("tabula.progress"),
  ...
)

\S4method{bootstrap_richness}{CountMatrix}(
  object,
  method = c("none", "margalef", "menhinick"),
  probs = c(0.05, 0.95),
  n = 1000,
  ...
)

\S4method{jackknife_richness}{CountMatrix}(object, method = c("none", "margalef", "menhinick"), ...)

\S4method{simulate_richness}{CountMatrix}(
  object,
  method = c("none", "margalef", "menhinick"),
  quantiles = TRUE,
  level = 0.8,
  step = 1,
  n = 1000,
  progress = getOption("tabula.progress"),
  ...
)
}
\arguments{
\item{object}{A \eqn{m \times p}{m x p} matrix of count data (typically
a \linkS4class{CountMatrix} object).}

\item{...}{Currently not used.}

\item{method}{A \code{\link{character}} string specifying the index to be computed
(see details). Any unambiguous substring can be given.}

\item{probs}{A \code{\link{numeric}} vector of probabilities with values in
\eqn{[0,1]} (see \code{\link[stats:quantile]{stats::quantile()}}).}

\item{n}{A non-negative \code{\link{integer}} giving the number of bootstrap
replications.}

\item{quantiles}{A \code{\link{logical}} scalar: should sample quantiles be used as
confidence interval? If \code{TRUE} (the default), sample quantiles are used as
described in Kintigh (1989), else quantiles of the normal distribution are
used.}

\item{level}{A length-one \code{\link{numeric}} vector giving the confidence level.}

\item{step}{A non-negative \code{\link{integer}} giving the increment of the
sample size. Only used if \code{simulate} is \code{TRUE}.}

\item{progress}{A \code{\link{logical}} scalar: should a progress bar be displayed?}

\item{diag}{A \code{\link{logical}} scalar indicating whether the diagonal of the
matrix should be plotted. Only used if \code{object} is a symmetric matrix.}

\item{upper}{A \code{\link{logical}} scalar indicating whether the upper triangle of
the matrix should be plotted. Only used if \code{object} is a symmetric matrix.}

\item{lower}{A \code{\link{logical}} scalar indicating whether the lower triangle of
the matrix should be plotted. Only used if \code{object} is a symmetric matrix.}
}
\description{
Deprecated Methods
}
\author{
N. Frerebeau
}
\keyword{internal}
